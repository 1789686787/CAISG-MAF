import time

import numpy as np

import conndb
import numpy


class explains:
    def __init__(self):
        self.k=4
        self.d=2
        self.l=1
        self.prov_list=[]
        self.question_tuple=[]
        self.mark = 0
        self.agg_function = ""
        self.db=conndb.dboperate()
        self.cur=self.db.get_cur()
        self.attr_list = []
        self.agg_attr = ""
        self.attr_num = 0
        self.len_al=len(self.attr_list)
        self.len_pl=len(self.prov_list)
        self.len_qt = len(self.question_tuple)
        self.hash_attr = {}
        self.unuse_list=[]
        self.use_list=[]
        self.explain_len = 0
        self.weight_list = []
        self.final = 0
        self.max_weight = 0
        self.explains_dict = {}
        self.sumtime  = 0
        self.table_name = ""
        self.con_sql = ""
        # 解释的最小属性数
        self.min_attr = 2
        self.max_attr = 5
    #   最终的解释字典
        self.final_explains={}
    def generator(self , prov_list , question_tuple , mark , agg_function , attr_list , agg_attr , table_name , con_sql):
        self.explain_len = 0
        self.question_tuple = question_tuple
        self.mark = mark
        self.agg_function = agg_function
        self.attr_list = attr_list
        self.agg_attr = agg_attr
        self.len_al=len(attr_list)
        self.len_pl=len(prov_list)
        self.len_qt = len(question_tuple)
        self.table_name = table_name
        self.con_sql = con_sql
        explains_list = []
        # 创建临时表
        self.db.create_table(self.table_name)
        # print(prov_list)
        # print(question_tuple)
        # print(mark)
        # print(agg_function)
        # print(attr_list)
        # print(self.agg_attr)
        # 去除多余数据
        for i in range(len(prov_list)):
            self.prov_list.append(prov_list[i][self.len_qt:])
        # print(self.prov_list)

        # 获取聚合值位置
        for i in range(self.len_al) :
            # print(self.attr_list[i][0] + "：" + self.agg_attr)
            if self.attr_list[i][0] == self.agg_attr :
                self.attr_num = i
                break

        # 找无效属性
        unuse_list=self.unuse_attr()

        # print(unuse_list)


        # 获取属性列表
        attr_list = self.get_attr()

        for i in range(len(attr_list)) :
            if len(attr_list[i]) == 1 :
                unuse_list[i] = 1

        # print(attr_list)
        # 求属性的权重(可解释度)
        self.weight_list = self.weight(attr_list , unuse_list)
        # print(self.weight_list)
        # print(unuse_list)
        # print(attr_list)
        # 计算解释中属性的个数
        explain_attrnum = 0
        for i in range(len(unuse_list)):
            if unuse_list[i] == 0:
                explain_attrnum += 1

        self.unuse_list = unuse_list
        self.use_list = attr_list
        # 计算解释的长度
        for i in range(len(self.unuse_list)) :
          if self.unuse_list[i] ==0 :
           self.explain_len +=1

        # print(self.prov_list)

        # 找到unuse_list的最后一个0
        for i in range(len(self.use_list)):
            if self.unuse_list[i] == 0:
                self.final = i
        # 生成解释
        for i in range(self.k) :
          self.explains_dict = {}
          self.generator_explains(1,{})
          best_rule = max(self.explains_dict, key=lambda x: self.explains_dict[x])
          print(best_rule)
          # 删除被规则覆盖的属性并把最佳规则添加到解释集合

          self.db.delete_table(str(best_rule).split(), self.table_name , self.unuse_list)
          self.final_explains.update({best_rule: self.explains_dict[best_rule]})

        # 删除这个表
        self.db.drop_table(self.table_name)
        # print("***************")
        # print(self.explains_dict)

        var = 0
        for rule in list(self.final_explains.keys()):

            explains_list.append([])
            list_rule = str(rule).split(' ')
            varcount1 = 0
            for i in range(len(self.unuse_list)) :
               # if self.unuse_list[i] == -1 :
               #     explains_list[var].append('*')

               if self.unuse_list[i] == 1 :
                   explains_list[var].append('*')

               if self.unuse_list[i] == 0 :
                   explains_list[var].append(list_rule[varcount1])
                   varcount1 += 1
            explains_list[var].append(self.final_explains[rule])
            var+=1

        print(self.sumtime)

        return explains_list


    # 获取待进入生成算法的属性
    def get_attr(self):
        useattr_list = []

        # 如果聚合函数是sum或avg
        if self.agg_function == "sum" or self.agg_function == "avg" :
            sum=0
            # 如果需要控制属性的百分率就用如下代码
            # for i in range(self.len_pl) :
            #     sum+=self.prov_list[i][self.attr_num]
            # print(sum/self.len_pl)
            # sum=sum/self.len_pl
            # p_index=0
            # if self.mark==1 :
            #     while(p_index<len(self.prov_list)) :
            #         if self.prov_list[p_index][self.attr_num] < sum:
            #           del self.prov_list[p_index]
            #           continue
            #         p_index+=1
            #
            # else :
            #     while(p_index<len(self.prov_list)) :
            #         if self.prov_list[p_index][self.attr_num] >= sum:
            #           del self.prov_list[p_index]
            #           continue
            #         p_index+=1

            # print(self.prov_list)
            for i in range(self.len_al) :
                temp_list=[]
                for j in range(len(self.prov_list)) :
                    if self.prov_list[j][i] not in temp_list :
                        temp_list.append(self.prov_list[j][i])
                useattr_list.append(temp_list)

            # for i in range(len(self.prov_list)) :
            #  print(self.prov_list[i])

        # 如果聚合函数是count或min或max
        if self.agg_function == "count" or self.agg_function == "min" or self.agg_function == "max" :

          for i in range(self.len_al):
            temp_list = []
            if self.attr_num == i :
                useattr_list.append(temp_list)
                continue

            for j in range(self.len_pl):
                if self.hash_attr[self.prov_list[j][i]] != 1 :
                  if self.prov_list[j][i] not in temp_list :
                    temp_list.append(self.prov_list[j][i])
            useattr_list.append(temp_list)

        # print(useattr_list)



        return useattr_list

    # 获取溯源表中无效的属性列 可设置比例参数
    def unuse_attr(self):
        unuse_list=[]
        for i in range(self.len_al):
            if self.attr_num == i:
                    continue
            for j in range(self.len_pl):
               # print(self.prov_list[j][i])
               if self.prov_list[j][i] in self.hash_attr :
                   self.hash_attr[self.prov_list[j][i]]+=1
               else :
                   self.hash_attr[self.prov_list[j][i]]=1
        # print(self.hash_attr)

        single_attr = int(0.6*self.len_pl)
        temp = 0
        for i in self.hash_attr:
            temp+=int(self.hash_attr[i])
            if self.hash_attr[i] == 1:
                single_attr-=1
            if temp ==self.len_pl :

                if single_attr <=0 :
                    unuse_list.append(1)
                else :
                    unuse_list.append(0)
                single_attr = int(0.6*self.len_pl)
                temp = 0
        unuse_list.insert(self.attr_num , -1)
        # print(unuse_list)

        return unuse_list



    # 计算所有待生成的属性的权重
    def weight(self ,attr_list , unuse_list):
        weight_list  = []
        max = 0
        sum = 0.00
        # 基于开根号归一化
        # for i in range(self.len_al) :
        #     if unuse_list[i] == 1 or unuse_list[i] == -1 or len(attr_list[i]) == 1 :
        #         weight_list.append(-1.00)
        #         continue
        #     else :
        #         weight_list.append(len(attr_list[i])**0.5)
        #         sum+=len(attr_list[i])**0.5
        # for i in range(len(weight_list)) :
        #     if weight_list[i] !=-1.0 :
        #         weight_list[i]=round(weight_list[i]/sum,2)
        #     if weight_list[i] > max :
        #        max = weight_list[i]

        # 所有属性权重均取1
        for i in range(self.len_al):
            if unuse_list[i] == 1 or unuse_list[i] == -1 or len(attr_list[i]) == 1 :
                weight_list.append(-1.00)
            else :
                weight_list.append(1.00)

        self.max_weight = max
        # print(weight_list)
        return weight_list

    # 解释的生成器，需要把所有处理好的的数据放进去
    def generator_explains(self, attrnum , current_list):

       create_rule = []
       current_list = current_list
       temp_list = {}
       current_max = 0



       t1 = time.clock()
       for i in range(self.explain_len) :
           create_rule.append('*')
       # 首次进入
       if attrnum == 1 :
           count = 0
           for i in range(len(self.use_list)) :
               if self.unuse_list[i] != 0 :
                   continue
               else :
                   for j in self.use_list[i] :
                     create_rule[count] = str(j)
                     temp_list[" ".join(create_rule)] = round(float(self.explain_match(create_rule)) * float(self.weight_list[i]),2)
                     if current_max < temp_list[" ".join(create_rule)] :
                         current_max = temp_list[" ".join(create_rule)]
                   create_rule[count] = '*'
                   count += 1
       else :

          for rule in  list(current_list.keys()) :
              count = 0
              list_rule=str(rule).split(' ')
              for i in range(len(self.use_list)):
                  if self.unuse_list[i] != 0:
                      continue
                  else :
                      if list_rule[count] == '*' :
                         for j in self.use_list[i] :

                             list_rule[count] = j
                             # print(" ".join('%s' %id for id in list_rule))

                             if  " ".join('%s' %id for id in list_rule) not in temp_list :
                                 # 查看是否满足剪枝的条件
                                 temp_count = 0
                                 weight_value = 0
                                 star_count = 0
                                 for k in range(len(self.use_list)):
                                     if self.unuse_list[k] != 0:
                                         continue
                                     else:
                                         if list_rule[temp_count] =='*' :
                                            star_count += 1
                                         else :
                                            weight_value += float(self.weight_list[k])
                                         temp_count +=1

                                 cont= float(self.explain_match(list_rule))

                                 # print(cont * (temp_count * self.max_weight + weight_value))
                                 if cont * (temp_count * self.max_weight + weight_value) > current_max:
                                   # print("cont " + str(cont) +" weight " + str(weight_value))
                                   temp_list[" ".join('%s' %id for id in list_rule)] = round(cont * weight_value,2)
                                   #     更新当前最大权重
                                   if current_max < temp_list[" ".join('%s' %id for id in list_rule)]:
                                       current_max = temp_list[" ".join('%s' %id for id in list_rule)]

                             list_rule[count] = '*'
                      count += 1

       # print(current_max)
       print(len(temp_list))

       print(temp_list)
       # for i in temp_list :
       #    if temp_list[i] == 0 :
       #        print(i)
       # 递归生成

       if attrnum >= 2 :
          self.explains_dict.update(temp_list)

       t2 = time.clock()
       print(t2-t1)

       if attrnum+1 <= self.explain_len-3 :
         self.generator_explains( attrnum+1 , temp_list )


       # return dict(sorted(self.explains_dict.items(), key=lambda x: x[1], reverse=True))


       return


    def explain_match(self , rule) :
       t1 = time.clock()
       # con_sum = 0
       # print(final)
       # sign_list = [0]*(len(object_list)+1)
       # sign_arr = np.full((len(object_list)), 0)
       # 一个一个比属性
       # for i in range(len(object_list)) :
       #    count = 0
       #    for j in range(len(self.use_list)):
       #        if self.unuse_list[j] != 0:
       #            continue
       #        else :
       #          if str(rule[count]) != str(object_list[i][j])  and rule[count] != '*' :
       #              # print(str(rule[count]) + " " + str(object_list[i][j]))
       #              break
       #          else :
       #              if j == self.final :
       #                  # print(rule)
       #                  if self.agg_function == "sum" or self.agg_function == "avg" :
       #                      con_sum += object_list[i][self.attr_num]
       #                  else :
       #                      con_sum += 1
       #              count += 1

       # 直接一列一列比属性
       # count = 0
       # for i in range(len(self.use_list)):
       #    if self.unuse_list[i] != 0:
       #        # print("***")
       #        continue
       #    else :
       #        for j in range(len(object_list)) :
       #           if sign_list[j] == 1 :
       #             continue
       #           else:
       #                # print(str(rule[count]) + " " + str(object_list[j][i]))
       #                if str(rule[count]) != str(object_list[j][i]) and rule[count] != '*':
       #                    sign_list[j] = 1
       #                    continue
       #                else :
       #                    if i == self.final and sign_list[j] == 0:
       #                        if self.agg_function == "sum" or self.agg_function == "avg":
       #                            con_sum += object_list[j][self.attr_num]
       #                            # print(rule)
       #                            # print(object_list[j][self.attr_num])
       #                        else:
       #                            con_sum += 1
       #        count += 1
       # 转换为sql语句的写法

       # con_sql = ""
       # tup_count=0
       # for i in range(len(self.unuse_list)):
       #
       #    if self.unuse_list[i] != 0 and rule[tup_count] !='*':
       #       con_sql += " and "+str(self.) + "='"+str(rule[tup_count])+"'"
       #       tup_count +=1
       # con_sql +=';'

       consum = self.db.contribution(rule , self.unuse_list ,self.table_name , self.con_sql)

       # print(sign_list)
       # print(rule)
       # print(object_list)
       t2 = time.clock()
       # print(self.sumtime)
       self.sumtime+=t2-t1
       if consum[0][0] == None :
           return 0.00
       else :
           return consum[0][0]



    def unuse_List_getter(self):
        return self.unuse_list
